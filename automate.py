# The goal of this script is to automate the process of creating the "hps_0.h" file for the HPS and
# to compile the HPS code.
# This script is intended to run on a Linux machine or in WSL with Quartus installed.
# The script should be run in the same directory as the Quartus project.

# The script will create the directory structure as shows below:
# Quartus_Project/
# ├─ automate.py
# ├─ C Code/
# │  ├─ hps_0.h
# │  ├─ main.c
# │  ├─ Makefile
# Only the C Code directory will be created by the script.

# Import the necessary packages
import os
import sys

# File paths that will be used in the script
# ============= EDIT THESE =============
embedded_path   = "/mnt/e/Quartus/embedded/" # Path to the embedded directory. Required
HPS_IP_ADDRESS  = "192.168.50.232"           # IP address of the HPS, use udhcpc -r ADDRESS to request a specific IP address. Use ifconfig to check the IP address. Optional
TARGET_NAME     = "my_first_hps"             # Name of the executable that will be generated by the Makefile. Required
# ======================================

# ==================== CONSTANTS ====================
HWLIBS_ROOT                     = embedded_path + "ip/altera/hps/altera_hps/hwlib"
HEADER_FILE_CREATION_COMMAND    = "sopc-create-header-files --single hps_0.h --module hps_0"
SCRIPT_PATH                     = os.path.dirname(os.path.realpath(__file__)) + "/" + __file__
# ===================================================

# ==================== MAKEFILE ====================
MAKEFILE = """
################################################################################
# Makefile for the DE1-SoC.                                                    #
# Tested with Quartus 15 / EDS SoC 15 on Windows 10 64-Bit                     #
#                                                                              #
# Copyright (C) 2015 by Joel Bodenmann <joel@embedded.pro>                     #
#                                                                              #
# Feel free to use this makefile without any warranty on your own risk.        #
################################################################################
 
# This is the name of the binaries that will be generated
TARGET                  = {TARGET_NAME}
 
# The device family (soc_cv_av = Cyclone V   ;   soc_a10 = Aria 10)
ALT_DEVICE_FAMILY       = soc_cv_av
 
# Some paths (Default should work)
HWLIBS_ROOT             = {HWLIBS_ROOT}
 
# Here we add all *.c files that we want to compile
CSRCS                   =
 
# Here we add all *.cpp files that we want to compile
CPPSRCS                 =
 
# Here we add the paths to all include directories
INCS                    =
 
# Parameters for SCP upload. Set up SSH keys to bypass password prompt
SCP_TARGET_IP           = {HPS_IP_ADDRESS}
SCP_USER                = root
SCP_TARGET_PATH         = /home/root
SCP                     = scp
SCP_FLAGS               =
 
# Compiler settings
ARCH                    = arm-linux-gnueabihf
LD                      = $(ARCH)-gcc
CC                      = $(ARCH)-gcc
CPPC                    = $(ARCH)-gcc
SIZE                    = $(ARCH)-size
CFLAGS                  = -g -std=gnu99 -Wall
CPPFLAGS                = -g -std=c++11 -Wall
LDFLAGS                 = -g -Wall
 
################################################################################
# Don't change anything below this line                                        #
################################################################################
 
# Some directory and file magic
BUILDDIR                = build
OBJDIR                  = $(BUILDDIR)/obj
 
# Generate the object names
OBJS                    = $(addprefix $(OBJDIR)/,$(addsuffix .o,$(basename $(CSRCS:%.c=%.o))))
OBJS                    += $(addprefix $(OBJDIR)/,$(addsuffix .o,$(basename $(CPPSRCS:%.cpp=%.o))))
 
# Add some paths
CFLAGS                  += $(INCS:%=-I%) -I$(HWLIBS_ROOT)/include -I$(HWLIBS_ROOT)/include/$(ALT_DEVICE_FAMILY) -D$(ALT_DEVICE_FAMILY)
CPPFLAGS                += $(INCS:%=-I%) -I$(HWLIBS_ROOT)/include -I$(HWLIBS_ROOT)/include/$(ALT_DEVICE_FAMILY) -D$(ALT_DEVICE_FAMILY)
LDFLAGS                 += $(INCS:%=-I%) -I$(HWLIBS_ROOT)/include -I$(HWLIBS_ROOT)/include/$(ALT_DEVICE_FAMILY) -D$(ALT_DEVICE_FAMILY)
 
# This is the default target if the user does just calls 'make'
all:
	@make clean
	@make build size
 
# Build all the files
build: builddirs $(BUILDDIR)/$(TARGET)
 
# Create the required directories (if not already existing)
builddirs:
	@mkdir -p $(BUILDDIR)
	@mkdir -p $(OBJDIR)
 
# Link everything together
$(BUILDDIR)/$(TARGET): $(OBJS)
	@echo Linking $@
	@$(LD) $(LDFLAGS) *.c -o $(BUILDDIR)/$(TARGET) $(OBJS)
 
# Compile c files
$(OBJDIR)/%.o: %.c
	@mkdir -p $(dir $@)
	@echo Compiling $^
	@$(CC) $(CFLAGS) -c -o $@ $^
 
# Compile cpp files
$(OBJDIR)/%.o: %.cpp
	@mkdir -p $(dir $@)
	@echo Compiling $^
	@$(CPPC) $(CPPFLAGS) -c -o $@ $^
 
# Print size information
size: $(BUILDDIR)/$(TARGET)
	@echo
	@echo
	$(SIZE) $^
 
# Clean up
clean:
	@rm -rf $(BUILDDIR) $(OBJS) $(TARGET) $(TARGET).* *.a *.o *~
	@echo Clean done
 
# Clean must be a phony target so make knows this never exists as a file
.PHONY: clean
 
# Upload to target
upload:
	$(SCP) $(SCP_FLAGS) $(BUILDDIR)/$(TARGET) $(SCP_USER)@$(SCP_TARGET_IP):$(SCP_TARGET_PATH)
 """.format(HWLIBS_ROOT=HWLIBS_ROOT, HPS_IP_ADDRESS=HPS_IP_ADDRESS, TARGET_NAME=TARGET_NAME)
# ==================================================

# ==================== EMBEDDED SHELL SCRIPT ====================
# This script has been taken from the Intel FPGA SoC Embedded Command Shell
# It has been modified to work with this python script
EMBEDDED_SHELL_SCRIPT = """
#!/bin/bash
############################################################
#                                                          #
# Intel FPGA SoC Embedded Command Shell                    #
#                                                          #
#                                                          #
# Copyright (c) 2020 Intel Corporation                     #
# All Rights Reserved.                                     #
#                                                          #
############################################################


############################################################
#
# Get the Root SOCEDS directory
#

if [ -n "${COMSPEC}" ]; then
    _IS_WINDOWS=1
 
    if [ "${SOCEDS_DESTROY_PATH}" == "1" ]; then	
        export ORIGINAL_PATH="${PATH}"
        PATH="/bin:/usr/bin"
    fi
fi

if [ "${_IS_WINDOWS}" = "1" ] && [ -n "$(which cygpath 2>/dev/null)" ]; then
    _IS_CYGWIN=1
fi

_SOCEDS_ROOT=$(cd "$(dirname "${0}")" && echo "$(pwd 2>/dev/null)")

if [ ! -d "${_SOCEDS_ROOT}" ]; then
    echo "${_SOCEDS_ROOT} not found. Invalid or corrupt SOCEDS Install" 1>&2
    exit 1
fi

export SOCEDS_DEST_ROOT="${_SOCEDS_ROOT}"
if [ "${_IS_CYGWIN}" == "1" ]; then
    SOCEDS_DEST_ROOT="$(cygpath -m "${SOCEDS_DEST_ROOT}" 2>/dev/null)"
fi

source "${_SOCEDS_ROOT}/env.sh"

############################################################


unset _SOCEDS_ROOT
unset _IS_WINDOWS
unset _IS_CYGWIN


if [ -n "$*" ]; then
    exec "$@"
else
    echo "------------------------------------------------"
    echo "Intel FPGA Embedded Command Shell"
    echo
    echo "Version 20.1 [Build 711]"
    echo "------------------------------------------------"


	
    # env.sh
    ############################################################
    #                                                          #
    # Intel FPGA SoC Embedded ENV Command Shell                #
    #                                                          #
    # Source this shell script to setup your env               #
    #                                                          #
    #                                                          #
    # Copyright (c) 2020 Intel Corporation                     #
    # All Rights Reserved.                                     #
    #                                                          #
    ############################################################


    ############################################################
    #
    # Convenience bash functions for setting up the environment
    #

    env_var_delete () {
        local var=${2:-PATH}
        local value
        local IFS=${3:-':'}
        for i in ${!var} ; do
            if [ "$i" != "$1" ] ; then
                value=${value:+$value:}$i
            fi
        done
        export $var="$value"
    }

    env_var_prepend () {
        env_var_delete "$1" "$2" "$3"
        local var=${2:-PATH}
        local sep=${3:-:}
        export $var="$1${!var:+${sep}${!var}}"
    }

    env_var_append () {
        env_var_delete "$1" "$2" "$3"
        local var=${2:-PATH}
        local sep=${3:-:}
        export $var="${!var:+${!var}${sep}}$1"
    }
    ############################################################


    ############################################################
    #
    # Host Machine Environment Setup
    #

    if [ -z "${_IS_CYGWIN}" ]; then    
        if [ -n "${COMSPEC}" ]; then
            _IS_WINDOWS=1
        fi
        
        if [ "${_IS_WINDOWS}" = "1" ] && [ -n "$(which cygpath 2>/dev/null)" ]; then
            _IS_CYGWIN=1
        fi        
    fi

    _SOCEDS_IS_32BIT="0"

    ############################################################


    ############################################################
    #
    # Setup Quartus Prime (if you can find it)
    #

    if [ -n "${QUARTUS_ROOTDIR_OVERRIDE}" ]; then
        _QUARTUS_ROOTDIR="${QUARTUS_ROOTDIR_OVERRIDE}"
    else
        _QUARTUS_ROOTDIR="$(cd ${SOCEDS_DEST_ROOT}/../quartus 2>/dev/null && echo $(pwd 2>/dev/null))"
        if [ -z "${_QUARTUS_ROOTDIR}" ]; then
            _QUARTUS_ROOTDIR="$(cd ${SOCEDS_DEST_ROOT}/../qprogrammer 2>/dev/null && echo $(pwd 2>/dev/null))"
        fi
        if [ -z "${_QUARTUS_ROOTDIR}" ] && [ -n "${QUARTUS_ROOTDIR}" ]; then
            _QUARTUS_ROOTDIR="${QUARTUS_ROOTDIR}"
        fi
    fi

    if [ -n "${_QUARTUS_ROOTDIR}" ] && [ -d "${_QUARTUS_ROOTDIR}" ]; then
    
        if [ "${_IS_CYGWIN}" = "1" ]; then
            _QUARTUS_ROOTDIR="$(cygpath -u "${_QUARTUS_ROOTDIR}" 2>/dev/null)"
        fi

    env_var_prepend "${_QUARTUS_ROOTDIR}/sopc_builder/bin"

    if [ -d "${_QUARTUS_ROOTDIR}/bin" ]; then
        env_var_prepend "${_QUARTUS_ROOTDIR}/bin"
    fi

    if [ -d "${_QUARTUS_ROOTDIR}/bin64" ]; then
        env_var_prepend "${_QUARTUS_ROOTDIR}/bin64"
    fi

    # Set QUARTUS_ROOTDIR because DS-5 requires this to find jtag libraries
    if [ "${_IS_CYGWIN}" = "1" ]; then
        export QUARTUS_ROOTDIR="$(cygpath -m "${_QUARTUS_ROOTDIR}" 2>/dev/null)"
    else
        export QUARTUS_ROOTDIR="${_QUARTUS_ROOTDIR}"
    fi

    fi

    unset _QUARTUS_ROOTDIR
    ############################################################


    ############################################################
    #
    # Setup Nios2eds (if you can find it)
    #

    if [ -n "${SOPC_KIT_NIOS2_OVERRIDE}" ]; then
        _SOPC_KIT_NIOS2=${SOPC_KIT_NIOS2_OVERRIDE}
    elif [ -n "${QUARTUS_ROOTDIR}" ]; then
            _SOPC_KIT_NIOS2="$(cd ${QUARTUS_ROOTDIR}/../nios2eds 2>/dev/null && echo $(pwd 2>/dev/null))"
    fi

    if [ -n "${_SOPC_KIT_NIOS2}" ]; then
        if [ "${_IS_CYGWIN}" = "1" ]; then
            _SOPC_KIT_NIOS2="$(cygpath -u "${_SOPC_KIT_NIOS2}" 2>/dev/null)"
        fi
        
        env_var_prepend "${_SOPC_KIT_NIOS2}/bin"
        env_var_prepend "${_SOPC_KIT_NIOS2}/sdk2/bin"
        
        if [ "${_IS_WINDOWS}" = "1" ]; then
            if [ "${_SOCEDS_IS_32BIT}" = "1" ]; then
                env_var_prepend "${_SOPC_KIT_NIOS2}/bin/gnu/H-i686-mingw32/bin"
            else
                env_var_prepend "${_SOPC_KIT_NIOS2}/bin/gnu/H-x86_64-mingw32/bin"
            fi
        else	
            if [ "${_SOCEDS_IS_32BIT}" = "1" ]; then
                env_var_prepend "${_SOPC_KIT_NIOS2}/bin/gnu/H-i686-pc-linux-gnu/bin"
            else
                env_var_prepend "${_SOPC_KIT_NIOS2}/bin/gnu/H-x86_64-pc-linux-gnu/bin"
            fi
        fi
        
        if [ "${_IS_CYGWIN}" = "1" ]; then
            export SOPC_KIT_NIOS2="$(cygpath -m "${_SOPC_KIT_NIOS2}" 2>/dev/null)"
        else
            export SOPC_KIT_NIOS2="${_SOPC_KIT_NIOS2}"
        fi
        
        unset _SOPC_KIT_NIOS2
    fi
    ############################################################


    ############################################################
    #
    # SoCEDS Environment setup
    #

    if [ -n "${SOCEDS_DEST_ROOT}" ]; then
        
        _SOCEDS_DEST_ROOT="${SOCEDS_DEST_ROOT}"
        
        if [ "${_IS_CYGWIN}" = "1" ]; then
            _SOCEDS_DEST_ROOT="$(cygpath -u "${_SOCEDS_DEST_ROOT}" 2>/dev/null)"
        fi

        if [ "${_IS_WINDOWS}" = "1" ] || [ "${_IS_CYGWIN}" = "1" ]; then
            _PYTHON_HOSTOS_OFFSET="host_tools/python"
        else
            _PYTHON_HOSTOS_OFFSET="host_tools/python/bin"
        fi

        #export ARM_TOOL_VARIANT=altera
        #export ARM_TOOL_VARIANT=eval_alt
        #export ARM_TOOL_VARIANT=pro
        #export ARM_TOOL_VARIANT=ds5eval
        #export ARM_TOOL_VARIANT=ult
        #export ARM_TOOL_VARIANT=ulteval

        if [ -z "${ARM_TOOL_VARIANT}" ]; then
        # Set default toolchain variant here
        # export ARM_TOOL_VARIANT=altera
        :
        fi
        
        if [ "${ARM_TOOL_VARIANT}" == "pro" ]; then
            unset ARM_TOOL_VARIANT
        fi

        # Add python to the global PATH only if you're on windows or USE_SOCEDS_PYTHON env var is set to 1 
        if [ "${USE_SOCEDS_PYTHON}" = "1" ] || [ "${_IS_WINDOWS}" = "1" ] || [ "${_IS_CYGWIN}" = "1" ]; then
            env_var_prepend "${_SOCEDS_DEST_ROOT}/${_PYTHON_HOSTOS_OFFSET}"
        fi

        # Add device tree compiler to PATH
        env_var_prepend "${_SOCEDS_DEST_ROOT}/host_tools/gnu/dtc"
    
        env_var_prepend "${_SOCEDS_DEST_ROOT}/host_tools/altera/secureboot"
        env_var_prepend "${_SOCEDS_DEST_ROOT}/host_tools/altera/imagecat"
        env_var_prepend "${_SOCEDS_DEST_ROOT}/host_tools/altera/diskutils"
        env_var_prepend "${_SOCEDS_DEST_ROOT}/host_tools/altera/device_tree"
        env_var_prepend "${_SOCEDS_DEST_ROOT}/host_tools/altera/mkpimage"
        env_var_prepend "${_SOCEDS_DEST_ROOT}/host_tools/altera/mkimage"
        env_var_prepend "${_SOCEDS_DEST_ROOT}/host_tools/altera/preloadergen"

        # prepend mingw gnu make to PATH
        if [ "${_IS_WINDOWS}" = "1" ]; then
            if [ "${_SOCEDS_IS_32BIT}" = "1" ]; then
                env_var_prepend "${_SOCEDS_DEST_ROOT}/host_tools/gnu/make/H-i686-pc-mingw32/bin"
            else
                env_var_prepend "${_SOCEDS_DEST_ROOT}/host_tools/gnu/make/H-x86_64-mingw32/bin"
            fi
        fi

        env_var_prepend "${_SOCEDS_DEST_ROOT}/host_tools/linaro/gcc/bin"

        unset _DS5_BINDIR
        unset _DS5_ROOT
        unset _PYTHON_HOSTOS_OFFSET
        unset _SOCEDS_DEST_ROOT
    else
        echo "ERROR: SOCEDS_DEST_ROOT not set"
    fi
    ############################################################


    ############################################################

    if [ -z "${QUARTUS_ROOTDIR}" ]; then
        echo "WARNING: QUARTUS_ROOTDIR is not set and could not be discovered. USB Blaster Support for DS-5 will not function if QUARTUS_ROOTDIR is not set to a valid Quartus Prime installation." 1>&2
    fi

    """ + """

    exec python3 "{SCRIPT_PATH}" c_hps_0
    
    unset _IS_WINDOWS
    unset _IS_CYGWIN
    unset _SOCEDS_IS_32BIT

    ############################################################
fi
""".format(SCRIPT_PATH=SCRIPT_PATH)


# ==================== MAINC ====================
MAINC = """
#include <fcntl.h>
#include <stdio.h>
#include <sys/mman.h>
#include <unistd.h>

#include "hps_0.h"
#include "hwlib.h"
#include "socal/alt_gpio.h"
#include "socal/hps.h"
#include "socal/socal.h"

#define HW_REGS_BASE (ALT_STM_OFST)
#define HW_REGS_SPAN (0x04000000)
#define HW_REGS_MASK (HW_REGS_SPAN - 1)

int main() {
    void *virtual_base;
    int fd;

    // map the address space for the LED registers into user space so we can interact with them.
    // we'll actually map in the entire CSR span of the HPS since we want to access various registers within that span

    if ((fd = open("/dev/mem", (O_RDWR | O_SYNC))) == -1) {
        printf("ERROR: could not open \\"/dev/mem\\"...\\n");
        return (1);
    }

    virtual_base = mmap(NULL, HW_REGS_SPAN, (PROT_READ | PROT_WRITE), MAP_SHARED, fd, HW_REGS_BASE);

    if (virtual_base == MAP_FAILED) {
        printf("ERROR: mmap() failed...\\n");
        close(fd);
        return (1);
    }

    // ========== USER CODE STARTS HERE ==========
    
    
    
    
    // ========== USER CODE ENDS HERE ==========

    // clean up our memory mapping and exit
    if (munmap(virtual_base, HW_REGS_SPAN) != 0) {
        printf("ERROR: munmap() failed...\\n");
        close(fd);
        return (1);
    }

    close(fd);
    return (0);
}
"""
# ==================================================

# main function
def main(argv):
    
    # Check arguments
    if len(argv) == 1:
        # ============ SETUP DIRECTORY ============
        # Check if the directory "C Code" exists
        if not os.path.exists("C Code"):
            # Create the directory
            os.makedirs("C Code")

        # Delete the "hps_0.h" file if it exists
        if os.path.exists("C Code/hps_0.h"):
            os.remove("C Code/hps_0.h")
        
        # Delete the "Makefile" file if it exists
        if os.path.exists("C Code/Makefile"):
            os.remove("C Code/Makefile")
        
        # Create the Makefile file and write the contents
        makefile_file = open("C Code/Makefile", "w")
        makefile_file.write(MAKEFILE)
        makefile_file.close()
        
        # If the "main.c" file does not exist, create it
        # If it does exist, do not overwrite it
        if not os.path.exists("C Code/main.c"):
            mainc_file = open("C Code/main.c", "w")
            mainc_file.write(MAINC)
            mainc_file.close()
        # =========================================
        
        # ============ GENERATE hps_0.h ============
        # First create a new temporary script in the embedded directory
        embedded_script_file = open(embedded_path + "tmp_embedded.sh", "w")
        embedded_script_file.write(EMBEDDED_SHELL_SCRIPT)
        embedded_script_file.close()
        
        # Now run the script
        os.system("bash '" + embedded_path  + "tmp_embedded.sh'")
        # The script will terminate the python script. Thus the tmp_embedded.sh script will run this script again,
        # with an argument of "c_hps_0". This will skip the above code and run the below code.
        # =========================================
    elif len(argv) == 2:
        if argv[1] == "c_hps_0":
            # ============ Create hps_0.h ============
            os.system(HEADER_FILE_CREATION_COMMAND)
            
            # Check if the "hps_0.h" file has been created successfully
            if not os.path.exists("hps_0.h"):
                print("====================================================================================")
                print("ERROR: hps_0.h file was not created successfully.")
                print("Please ensure that you are running this script in the Quartus project directory.")
                print("====================================================================================")
                exit()

            # Remove the "hps_0.h" file from the "C Code" directory if it exists
            if os.path.exists("C Code/hps_0.h"):
                os.remove("C Code/hps_0.h")
            
            # Move the "hps_0.h" file to the "C Code" directory
            os.system("mv hps_0.h C\ Code/")
            
            # ============== Success ===============
            print("====================================================================================")
            print("hps_0.h file has been created successfully.")
            print("The C Code directory now contains the following files:")
            os.system("cd C\ Code/ && ls")
            print("====================================================================================")
            
            
            # Delete the temporary script
            os.remove(embedded_path + "tmp_embedded.sh")
            # ======================================
    
if __name__ == "__main__":
    main(sys.argv)